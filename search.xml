<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模块化</title>
      <link href="/2019/03/12/%E5%89%8D%E7%AB%AF%E6%9C%AC%E8%B4%A8%E8%AE%BA%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/03/12/%E5%89%8D%E7%AB%AF%E6%9C%AC%E8%B4%A8%E8%AE%BA%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript发展初期就是为了实现简单的页面交互逻辑,寥寥数语即可;如今CPU、浏览器性能得到了极大的提升,很多页面逻辑迁移到了客户端（表单验证等）,随着web2.0时代的到来,Ajax技术得到广泛应用,jQuery等前端库层出不穷,前端代码日益膨胀,此时在JS方面就会考虑使用模块化规范去管理.<br><a id="more"></a></p><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1552401017&amp;ver=1480&amp;signature=dpwxyPPMNWc2sx1LyX5uX4ADzbnwE-0sQrXgJXzU2yDzn*vE3OYC*5fLFppSszerMh1N2YVjKNj9fvVtBwGRzgn00v1OSPsiIgvhBn1ywZFG0o5tf6nIEwWJhvTHgaeh&amp;new=1" target="_blank" rel="noopener">参考1</a><br><a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1552401943&amp;ver=1&amp;signature=xP*ZZ4FJz0-Uxu7tQEuemE0kFhqxRSGgHJw*tyk0acW12nxepicq3kcipIM93pd3MEtNN2dQ0dARIZmBHmpgl4ZFSRvkmES2bORkxIybhYh7Nokf9aLN4jlbbePUGtREbaioEHS8vrw*29YOEDo7ZTxWcb*hfj-yYdnn0Zezjns=" target="_blank" rel="noopener">参考2</a><br><a href="http://fex.baidu.com/" target="_blank" rel="noopener">优秀前端站点</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0ODA2ODU2NQ==&amp;mid=2651128661&amp;idx=1&amp;sn=e9c613d5fae6f9e3733be98168bd3cc6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">前端Web开发发展史</a><br><a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1552403777&amp;ver=1&amp;signature=D6Uk6MGwsbQAvfVxRXcw-hnaxEJMuZHUIL3AYISwskDGaASYZgww*cvdXcxqvSsRl1f0qDkRiyb80zMYAov1s9*ZNkC93YgKOc0B4My*jDC*wpLQuDoYsUmTr6YcQIga18zn19CcLCfiz53ASAKTLSBv1gUIZg0M4pcl1pANDs8=" target="_blank" rel="noopener">模块化与组件化</a></p><h2 id="模块化实现"><a href="#模块化实现" class="headerlink" title="模块化实现"></a>模块化实现</h2><p>早期的javascript版本没有块级作用域、没有类、没有包、更没有模块.所以最初开发者在构造大型复杂的页面逻辑时需要自己使用已有的功能来模拟实现模块化.</p><h3 id="函数封装方式"><a href="#函数封装方式" class="headerlink" title="函数封装方式"></a>函数封装方式</h3><p>将相关逻辑的函数定义到一个js文件中,一个js文件就代表一个模块.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">element</span>) </span>&#123; <span class="comment">// 展示一个元素 &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">element</span>) </span>&#123; <span class="comment">// 隐藏一个元素 &#125;</span></span><br></pre></td></tr></table></figure></p><p>使用时引用相关的js文件.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/utils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/page-1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/page-2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>存在的问题</strong></p><ol><li>全局变量冲突风险:如果编写page-1的同学不知道utils里面有一个show/close方法，然后他自个也写了一个，同时还添加了额外逻辑，自然就覆盖了utils的方法.那么page-2同学在不知道的情况下调用了这方法，自然会发生错误.</li><li>人工维护依赖关系:如果page-2的文件里引用了page-1的里的函数,那么在加载js文件时必须要先加载page-1再加载page2，否则会报错.如果js文件很多时并且并不清楚他们之间的依赖关系时很难进行后期的维护工作.</li></ol><h3 id="对象封装方式"><a href="#对象封装方式" class="headerlink" title="对象封装方式"></a>对象封装方式</h3><p>为了改进函数封装带来的问题,开发者又想到了通过对象封装的方式来试图解决它的问题.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = &#123;</span><br><span class="line">    _name:<span class="string">'tony'</span>,</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;&#125;,</span><br><span class="line">    close:<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式同样存在对象名全局冲突的问题,所以聪明的开发者又想到了类似于Java这种正式语言的命名空间的方法来规范命名从而解决命名冲突的问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company.project.module.utils = &#123;</span><br><span class="line">    _name: ‘baotong.wang’,</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;&#125;,</span><br><span class="line">    close: <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>存在的问题</strong></p><ol><li>命名空间过长导致代码输入困难,因为是动态脚本语言,所以它注定没有任何一个IDE可以实现通过<code>.</code>符号来一路点下去来完成输入.</li><li>任何人都可以直接修改对象的成员变量,导致代码安全问题.</li></ol><h3 id="闭包封装方式"><a href="#闭包封装方式" class="headerlink" title="闭包封装方式"></a>闭包封装方式</h3><p>为了解决对象封装方式带来的内部成员变量安全问题,聪明的开发者又想到了通过立即执行函数的方式来解决这个问题,并且通过结合命名空间规范,已经基本达到了实现模块化的目的了.<br>通过全局命名空间变量来访问模块的函数,同时由于函数内的变量只存在于函数体内部,外部也就无法任意修改模块的成员变量了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> Company = Company || &#123;&#125;;</span><br><span class="line">   Company.Project = Company.Project || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> _name = <span class="string">'tony'</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">show</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">hide</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   Company.Project.Module.Utils = &#123;</span><br><span class="line">     show: show,</span><br><span class="line">     hide: hide</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="真正的模块化"><a href="#真正的模块化" class="headerlink" title="真正的模块化"></a>真正的模块化</h3><ol><li>模块独立:不能引发命名冲突以及限制模块作用域.</li><li>依赖管理:自动化处理依赖关系</li></ol><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><p>通过上面的描述,我们知道了如何通过js原生功能来模拟实现模块化方案.但这仅仅只是一种还不算完美的实现思路,各家公司内部在进行前端开发时都会有一套自己的模块化实现方案.为了实现模块化方案的统一,模块化规范也就应运而生.</p><h4 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h4><p>1</p><h4 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h4><p>2</p><h4 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h4><p>3</p><h4 id="UMD规范"><a href="#UMD规范" class="headerlink" title="UMD规范"></a>UMD规范</h4><p>4</p><h2 id="原生模块化"><a href="#原生模块化" class="headerlink" title="原生模块化"></a>原生模块化</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
